{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://holdfire.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-10-25T15:05:32.600Z","updated":"2019-10-25T11:35:08.028Z","comments":false,"path":"about/index.html","permalink":"http://holdfire.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2019-10-25T19:41:07.133Z","updated":"2019-10-25T11:35:08.034Z","comments":false,"path":"books/index.html","permalink":"http://holdfire.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-25T15:06:18.978Z","updated":"2019-10-25T11:35:08.041Z","comments":false,"path":"categories/index.html","permalink":"http://holdfire.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-10-26T09:18:00.989Z","updated":"2019-10-25T11:35:08.047Z","comments":true,"path":"links/index.html","permalink":"http://holdfire.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-10-25T11:35:08.054Z","updated":"2019-10-25T11:35:08.054Z","comments":false,"path":"repository/index.html","permalink":"http://holdfire.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-25T11:35:08.060Z","updated":"2019-10-25T11:35:08.060Z","comments":false,"path":"tags/index.html","permalink":"http://holdfire.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++学习——内存分配","slug":"cpp-memory-allocation","date":"2019-10-29T19:55:20.000Z","updated":"2019-10-29T19:57:02.240Z","comments":true,"path":"2019/10/30/cpp-memory-allocation/","link":"","permalink":"http://holdfire.github.io/2019/10/30/cpp-memory-allocation/","excerpt":"","text":"1. 栈区 由编译器自动分配和释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 2. 堆区 一般有程序员分配和释放，用new运算符申请；若程序员不释放，程序结束时可由OS回收。 3. 全局区（静态区） 全局变量（main函数前声明的变量）和静态变量的存储放在一起。其中，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在一块区域。 4. 文字常量区 常量字符串存储的地方。 5. 程序代码区 存放函数体的二进制码。","categories":[{"name":"Programming Language","slug":"Programming-Language","permalink":"http://holdfire.github.io/categories/Programming-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://holdfire.github.io/tags/C/"}]},{"title":"C++学习——左值与右值","slug":"cpp-left-value-right-value","date":"2019-10-29T18:12:27.000Z","updated":"2019-10-29T19:32:27.302Z","comments":true,"path":"2019/10/30/cpp-left-value-right-value/","link":"","permalink":"http://holdfire.github.io/2019/10/30/cpp-left-value-right-value/","excerpt":"","text":"1. 基本定义 可以放到赋值操作符左边的是左值，可以放到赋值操作符右边的是右值; 左值的声明符号为&amp;，右值的声明符号为&amp;&amp;； 左值是可以取地址的对象或变量，可以作为右值使用； 右值通常是临时对象、常量等，不能作为左值使用； 右值分为纯右值(Pure RValue，如非应用返回的函数返回值，表达式等)和将亡值(eXpiring Value); 2. 左值引用和右值引用 2.1 基本定义 左值引用和右值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。 左值引用是具名变量值的别名，通常不能绑定到右值。非常量左值只能接受非常量左值对其进行初始化。 右值引用是不具名（匿名）变量的别名。 右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。 2.2 C++11中各引用类型可以引用的值类型 非常量左值引用： 非常量左值； 常量左值引用： 非常量左值；常量左值；非常量右值；常量右值； 非常量右值引用： 非常量右值； 常量右值引用： 非常量右值；常量右值。 2.3 特点 常量左值引用是个全能的引用类型，可用于拷贝语义。它可以接受非常量左值、常量左值、右值对其进行初始化。 非常量右值引用用于移动语义，完美转发。 2.4 示例 1234567891011int a = 1; //正确，变量a可以是左值int &amp;b = a; //正确，因为a是左值，引用类型变量的赋值表达式里，右边必须是左值int &amp;c = 5; //错误，因为5是一个字面值，是右值不是左值int const &amp;d= 100; //正确，是为了能将临时对象作为引用参数传递给函数，为啥？const int &amp;c = b; //常量左值引用绑定到非常量左值，编译通过const int d = 2; //常量左值const int &amp;e = c; //常量左值引用绑定到常量左值，编译通过const int &amp;b =2; //常量左值引用绑定到右值，编译通过int &amp;&amp;r1 = c; // 编译失败，因为c是一个左值int a;int &amp;&amp;r2 = std::move(a); //编译通过 3. 常见例子 3.1 函数的返回值 如果一个函数的返回值是一个临时对象，就是右值。如果返回值为引用，由于引用是对象的别名，通过引用可以改变对象的值，是左值。 12345int arr[] = &#123;1,2,3,4,5&#125;;int fun1(int i)&#123;return arr[i];&#125;int&amp; fun2(int i)&#123;return arr[i];&#125;fun1(0) = 10; // 错误，fun1()是右值，不能被赋值；fun2(0) = 10; // 正确，fun2()是左值，可以被赋值； 3.2 前置和后置 前置的返回值是被的对象的引用，是一个可寻址的变量。返回值是左值，可以被赋值，如++i=3。 后置的返回值是被对象的原始值，是一个临时对象。返回值是右值，不可以作为左值，代码i++=3是错误的。 下面的代码是C中前置和后置++的实现： 1234// 前置++的实现T&amp; T::operator++() &#123;++*this; return this;&#125;// 后置++的实现T T::operator++(int)&#123;T old(*this); ++(*this); return old;","categories":[{"name":"Programming Language","slug":"Programming-Language","permalink":"http://holdfire.github.io/categories/Programming-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://holdfire.github.io/tags/C/"}]},{"title":"C++学习——指针","slug":"cpp-pointer","date":"2019-10-29T15:31:44.000Z","updated":"2019-10-29T18:40:21.218Z","comments":true,"path":"2019/10/29/cpp-pointer/","link":"","permalink":"http://holdfire.github.io/2019/10/29/cpp-pointer/","excerpt":"","text":"1. 简介 1.1 指针 1.2 空指针 1.3 智能指针 2.1(int*)a 和 int *a的区别？ 3. 指针和引用","categories":[{"name":"Programming Language","slug":"Programming-Language","permalink":"http://holdfire.github.io/categories/Programming-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://holdfire.github.io/tags/C/"}]},{"title":"C++学习——引用","slug":"cpp-reference","date":"2019-10-29T15:31:23.000Z","updated":"2019-10-29T18:26:54.121Z","comments":true,"path":"2019/10/29/cpp-reference/","link":"","permalink":"http://holdfire.github.io/2019/10/29/cpp-reference/","excerpt":"","text":"1. 简介 引用是一种特殊的变量，可以被认为是一个变量的别名。 引用变量和原变量取地址运算&amp;的结果相同。 声明一个引用时，必须同时对它进行初始化，使它指向一个已经存在的对象。 一旦一个引用被初始化后，就不能改为指向其他对象。 2. 引用作为函数参数 2.1 引用传递和值传递 函数在被调用时，若发生的是值传递，形参会被分配内存单元并与实参结合；若发生的是引用传递(函数的形参为引用)，由于形参时实参的一个别名，对形参的任何操作都会直接作用于实参。 下方代码中：执行fun1(x1)时参数传递方式为值传递，形参会被分配内存单元，函数调用完后x1的值仍为0。执行fun1(x1)时参数传递方式为引用传递，函数调用栈中不会产生变量x2的副本，而是直接用变量x2的值进行运算，函数调用完后x2的值为1。 12345void fun1(int a) &#123;a++; return;&#125;void fun2(int &amp;a)&#123;a++; return;&#125;int x1 = 0, x2 = 0;fun1(x1);fun2(x2); 2.2 引用传递——形参为常引用 如果一个函数的形参被申明为常引用，那么在函数体中，就不能修改该引用变量的值，达到了引用的安全性。下方代码将会报错：常引用对象a为只读对象，不能进行a++操作。 123void fun3(const int &amp;a)&#123;a++; return;&#125;int x3 = 0; fun3(x3)； 2.3 引用传递——形参为引用时需注意 如果一个函数的形参为引用时，那么需要注意传递的实参不能为const类型。而C++中的临时对象都是const类型的！ 如函数的返回值，未命名的内容都是临时变量，因而下面的代码会运行错误。如果把fun4()的形参设为(int a)或者(const int &amp;a)，代码就可以正常运行了。 所以，引用型参数应该在能被定义为const的情况下，尽量定义为const! 1234void fun4(int &amp;a)&#123;&#125;int helper()&#123;return 0;&#125;fun4(helper())； // 错误：helper()返回的临时对象是const类型，不能作为实参fun4(0); // 错误：未命名的数字0是const类型，不能作为实参 3. 引用作为函数返回值 引用作为函数的返回值时，内存中不会产生返回值的副本。 返回的应该是一个函数外就存在的对象； 返回对象不能是函数体内局部变量的引用，因为函数调用完毕，局部变量就不存在了； 返回对象不能是表达式，不能是new分配的对象。 123456int arr[] = &#123;1,2,3,4,5&#125;;int&amp; fun5(int i)&#123;return arr[i];&#125;int i = 0;cout&lt;&lt;&amp;arr[i]&lt;&lt;endl; // 返回结果：0x100402010cout&lt;&lt;&amp;fun5(i)&lt;&lt;endl; // 返回结果：0x100402010fun5(i) = 10; // 这也可以，牛不，就因为人家函数的返回值为引用，是左值，可以被赋值 返回值为引用时，为左值，返回值可以被赋值、取地址等操作！ 返回值不是引用时，为右值，如下方代码所示。 123456int arr[] = &#123;1,2,3,4,5&#125;;int fun6(int i)&#123;return arr[i];&#125;int i = 0;cout&lt;&lt;&amp;arr[i]&lt;&lt;endl; // 返回结果：0x100402010cout&lt;&lt;&amp;fun6(i)&lt;&lt;endl&gt;&gt;; // 错误，返回值为右值，不能取地址；fun6(i) = 10; // 错误，不可以的兄弟，fun6的返回值是右值 4. 引用总结 引用传递主要应用在函数参数传递上，传送较大数据和对象时，内存中不会产生副本，节约了内存空间； 用const将参数设置为常引用，用以保证引用变量不被随意修改； 跟指针变量相比，引用可以看做变量的别名，代码可读性强，在C++中推荐使用引用而非指针作为函数的参数；","categories":[{"name":"Programming Language","slug":"Programming-Language","permalink":"http://holdfire.github.io/categories/Programming-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://holdfire.github.io/tags/C/"}]},{"title":"C++学习——多态性","slug":"cpp-polymorphism","date":"2019-10-29T11:20:16.000Z","updated":"2019-10-29T20:06:48.098Z","comments":true,"path":"2019/10/29/cpp-polymorphism/","link":"","permalink":"http://holdfire.github.io/2019/10/29/cpp-polymorphism/","excerpt":"","text":"1. 简介 1.1 C++的4种多态 多态性是指一段程序能够处理多种类型对象的能力。C++中可以通过强制多态、重载多态、类型参数化多态、包含多态4种形式实现。前两种是表面的多态性，后两种是真正的多态性。 强制多态：将一种类型的数据强制转化成另一种类型（隐式转换或显式转换） 重载多态：是指给同一个名字赋予不同的含义 参数化多态：通过模板实现，分为函数模板和类模板两种 包含多态：通过虚函数实现，虚函数是多态性的精华 1.2 静态绑定和动态绑定 多态性还可以分成编译时的多态和运行时的多态：其中，绑定工作在编译连接阶段完成的情况称为静态绑定，在程序运行阶段完成的情况称为动态绑定。绑定时指计算机程序自身彼此关联的过程，用面向对象的术语讲，就是把一条消息和一个对象的方法相结合的过程 2. 强制多态 3. 重载多态 4. 参数化多态 5. 包含多态","categories":[{"name":"Programming Language","slug":"Programming-Language","permalink":"http://holdfire.github.io/categories/Programming-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://holdfire.github.io/tags/C/"}]},{"title":"C++学习——const限定符","slug":"cpp-const","date":"2019-10-29T10:57:15.000Z","updated":"2019-10-29T18:40:52.256Z","comments":true,"path":"2019/10/29/cpp-const/","link":"","permalink":"http://holdfire.github.io/2019/10/29/cpp-const/","excerpt":"","text":"1. const简介 简介：用const关键字修饰的内容为常量，其值初始化后就不允许修改。 命名：常用的做法是将这个常量的首字母或全部大写，以提醒用户这是个常量。 初始化：在声明一个常量时就应该将其初始化，如const int Name = value;。 替换：C语言中通常使用#define来定义常量，而const能够明确指定类型和限定作用域，优于前者。 优点：在函数的参数传递中，在引用传递前加上const限定符，可以防止输入变量被修改。 2. const的用法 const可以用来修饰整型变量、引用变量、指针变量、函数、对象、数组等。修饰的是其左边相邻的内容，如果左边没有内容，则修饰右边相邻的内容。 12int age = 3; // 我的年龄age是个整型变量，可以修改，我今年3岁const int Age_Mao = 83; // age_Mao是由const修饰的常量，其值初始化后不能修改 2.1 常引用 下面的year就是对变量age的一个常引用，不能通过year修改age的值，但可直接修改age的值。常引用的这一优点可以应用在函数的参数传递上，既能节约内存，也能防止引用对象被修改。 123const int &amp;year = age; // year是一个常引用*b = 4; // 错误，常引用year，你是常引用，你不能改我的age啊age = 4; // 正确，我的年龄age可以通过赋值修改，明年我4岁 2.2 常指针 指针p指向age所在地址，不能指向别的。 1int *const pt1 = &amp;age; 2.3 指向常量的指针 如下所示：pt2和pt3均为指向常量的指针，不能通过指针来修改age或者age_Mao。（但age可直接修改，age_Mao不能修改） 123const int *pt2 = &amp;age; const int *pt3 = &amp;Age_Mao;int *p4 = &amp;Age_Mao; // 错误用法：禁止将const的地址附给非const指针(但const_cast可强制转换) 2.4 复杂情况：将指针指向指针 参考《C++ Primer Plus》P222 12int *pd = &amp;age; // *pd = 4 是有效的const int *pt = pd; // *pt = 4 是无效操作(一级间接关系) 3. 常成员函数 1类名::fun(形参) const; // 常成员函数： 4. 常对象 1类名 const 对象名; // 常对象： 5. 其他 1int const 数组名[]; // 常数组： 6. const_cast","categories":[{"name":"Programming Language","slug":"Programming-Language","permalink":"http://holdfire.github.io/categories/Programming-Language/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://holdfire.github.io/tags/C/"}]},{"title":"Linux学习——Linux命令介绍","slug":"linux-command","date":"2019-10-26T21:25:15.000Z","updated":"2019-10-26T22:54:50.712Z","comments":true,"path":"2019/10/27/linux-command/","link":"","permalink":"http://holdfire.github.io/2019/10/27/linux-command/","excerpt":"","text":"1. 简介 1.1 Linux命令分类 Linux命令分为两种，一种是shell内置命令，一种是外部命名。在命令行输入type command可以区分。 1.2 帮助使用Linux命令 对于一些内部命令，可以有： 123man bash # 查看所有的内部命令man help # 得到所有内建命令列表及使用方法help command # 得到该命令的具体信息 对于外部命令，可以有： 1234command --help # 得到该命令的帮助信息command -h # 同上man command # info command # 1.3 Linux执行命令的查找顺序 环境变量$PATH：决定了shell在哪些目录中寻找命令或程序。由左到右依次在这些目录中查找，以先找到的为准。命令行输入echo $PATH可以查看环境变量。 1.4 Linux常用命令的存放位置 在命令行输入完一个命令后，shell会在下面几个目录查找是否有该命令： 12345/bin # 存放普通用户经常使用的命令，如cp,mv,kill/sbin # 存放系统管理员才能使用的系统管理程序，如ping,ifconfig/usr/bin # 存放普通用户使用的应用程序，如python,vi/usr/local/bin # 存放用户下载安装的软件或者自己编写的可执行文件，如pip,virtualenv,MySQL/usr/sbin # 存放系统管理员使用的比较高级的管理程序和系统守护程序","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://holdfire.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://holdfire.github.io/tags/Linux/"}]},{"title":"Linux学习——系统目录结构","slug":"linux-system-directory","date":"2019-10-26T21:23:19.000Z","updated":"2019-10-26T21:24:03.838Z","comments":true,"path":"2019/10/27/linux-system-directory/","link":"","permalink":"http://holdfire.github.io/2019/10/27/linux-system-directory/","excerpt":"","text":"1. 简介","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://holdfire.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://holdfire.github.io/tags/Linux/"}]},{"title":"Linux学习——文件系统与目录篇(1)","slug":"linux-file-directory-1","date":"2019-10-26T19:17:45.000Z","updated":"2019-10-26T19:21:15.427Z","comments":true,"path":"2019/10/27/linux-file-directory-1/","link":"","permalink":"http://holdfire.github.io/2019/10/27/linux-file-directory-1/","excerpt":"","text":"1. Linux的文件权限","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://holdfire.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://holdfire.github.io/tags/Linux/"}]},{"title":"Linux学习——简介","slug":"linux-introduction","date":"2019-10-26T16:10:34.000Z","updated":"2019-10-26T22:58:33.456Z","comments":true,"path":"2019/10/27/linux-introduction/","link":"","permalink":"http://holdfire.github.io/2019/10/27/linux-introduction/","excerpt":"","text":"1. Linux简介 Linux是一个GNU GPL授权模式的开源的操作系统。操作系统由内核和系统调用组成,操作系统是应用程序和计算机硬件沟通的桥梁。即：硬件–&gt;内核–&gt;系统调用–&gt;应用程序(Shell)。 1.1 Linux内核版本与发行版本 Linux内核版本是单线发展的，其版本号由“主版本.次版本.末版本”的格式构成。截至2019年10月27日，最新的Linux稳定内核版本为5.3.7版。 Linux发行版本是由“Linux内核+软件+工具+文件”组成的一个完整的安装程序，不同的厂商提供不同的发行版本，主要分为两大类： 使用rpm/yum包管理方式的系统，包括：RedHat,Fedora,CentOS等； 使用apt-get/dpkg包管理方式的系统，包括：Debian,Ubuntu等； 1.2 Linux的特点 Linux严格区分大小写； Linux中一切内容皆文件（包括硬件）； Linux不依靠拓展名区分文件类型，而是依据文件权限； 通常，压缩包的后缀为.gz .bz2 .tar .bz2 .tgz；二进制软件包为.rmp；脚本文件为 .sh 2. Linux文件系统和目录 3. Shell与Shell Script 4. Linux用户管理 5. Linux系统管理","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://holdfire.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://holdfire.github.io/tags/Linux/"}]},{"title":"Linux学习——Shell篇(1)","slug":"linux-shell-1","date":"2019-10-26T16:00:27.000Z","updated":"2019-10-27T08:07:49.296Z","comments":true,"path":"2019/10/27/linux-shell-1/","link":"","permalink":"http://holdfire.github.io/2019/10/27/linux-shell-1/","excerpt":"","text":"1. Shell是什么？ 1.1 正规军的解释 Shell是一个用C语言编写的程序！Shell是一个命令解释器！Shell是一种命令语言！Shell是一种程序设计语言！Shell是系统的用户界面，提供了用户与内核进行交互操作的接口！上面是网上找到的关于Shell的大部分解释，听着是不是让人头大？是的？！那就忘掉它，看看下面两个场景先。 1.2 接待员老白和Shell 场景A：你去同福客栈吃饭，你对接待员老白说：“我要一份酸菜鱼。”老白对着你点头微笑表示ok，然后跑去前台的点菜机上噼里啪啦输入一堆信息，该消息随后传到了后厨李大嘴那里，李大嘴开始鼓捣起他的菜刀、砧板、狼牙棒等厨具。一个时辰过后，你的桌上终于出现了一份既不好看也不好吃的酸菜鱼。 场景B：你在Linux终端工具上写代码，你写下了一行echo &quot;Hello, world&quot;,Shell对这行代码进行了解释，然后系统调用收到了该解释信息，信息接下来被传到了内核那里，内核开始控制CPU、内存、显卡等设备。一眨眼的时间，你的显示器上就出现了&quot;Hello, world&quot;这行字。 补充概念（此处可不看）：计算机的硬件由CPU、内存、显卡、磁盘等组成。操作系统包括内核和系统调用，内核（kernel，包括CPU调度、内存管理、磁盘输入输出等）直接控制上述硬件，系统调用是应用程序同系统之间的接口(API)，eg:Linux操作系统中如内存管理、网络、Socket套接字、进程间通信等接口。 1.3 游击队的解释 场景A中信息的流动方向是：你说的话–&gt;接待员老白–&gt;点菜机—&gt;李大嘴–&gt;厨具，场景B中信息的流动方向是：你的代码–&gt;Shell–&gt;系统调用—&gt;内核–&gt;硬件。仅考虑信息的流动方向，我们可以认为场景A等价于场景B。那么在场景A中，你说的话就是你的代码，接待员老白就是Shell，点菜机就是系统调用，李大嘴就是内核，厨具就是计算机的各种硬件。再回过头来看下1.1中Shell的解释，是不是就很好理解了呢？如果再有人问你Shell是什么，你就告诉他：Shell就是个接待员！ 2. Shell简介 2.1 Shell版本家族 常见的shell有Bourne shell(简称sh),在Sun里默认的C shell(简称csh)等。Linux使用的版本是Bourne Again Shell(简称bash)，它是Bourne shell的增强版本。 2.2 Linux中的Bash shell 使用man bash命令可以查看Bash shell的说明文档。用户在登录linux时，系统会分配一个shell用来工作，这个shell记录在/etc/passwd中。此外，/etc/shells文件中记录了当前可以使用的shell种类。作者在ubuntu16.04.5上查看的结果如下： 1234/bin/sh # 已经被/bin/bash所替换/bin/dash/bin/bash # Linux默认的shell/bin/rbash 3. Shell作为一个C语言程序 以Linux系统中Bash shell为例，主要有下面的优点： 历史命令(history)：历史命令保存在用户家目录~/.bash_history文件中。需要注意该文件记录的是这次登陆之前执行过的命令，这次登录执行过得命令缓存在内存中，注销系统后才会被保存。 命令与文件补全功能(Tab按键) :不仅能少打字，还能确保你的输入是正确的。 命令别名设置(alias) :在命令行输入alias就能查看当前命令的别名，这些别名保存在用户家目录~/.bashrc文件中。 任务管理、前台、后台控制(job control,foreground,background) :可以随时将任务丢到后台中执行，防止不小心使用ctrl+c停止程序。 通配符(Wildcard) :bash支持许多通配符来帮助用户查询与执行命令。 4. Shell作为命令语言和命令解释器 4.1 Bash shell的内置命令 Linux命令分为两种，一种是shell内置命令，一种是外部命名。使用type命令可以查看。 4.2 命令的执行 命令太长时，可以使用反斜杠\\对[Enter]键进行转义，注意两者中间不能有其他字符 4.3 命令的快速编辑 一些方便的命令快速编辑按钮 1234ctrl+u: 从光标处向前删除命令串ctrl+k: 从光标处向后删除命令串ctrl+a: 让光标移动到命令串最前面ctrl+e: 让光标移动到命令串最后面 5. Shell作为程序设计语言 Shell的优点是可以作为一种程序设计语言，通过编写程序化脚本(shell scripts)，可以将需要连续执行的命令写成一个shell脚本文件来执行。shell脚本主要有2中运行方式： 5.1 脚本作为可执行程序 假设有一个test.sh的shell脚本文件，存放在path目录下，则执行方法为： 123cd path # 切换至脚本所在目录pathchmod +x ./test.sh # 使脚本具有执行权限./test.sh # 执行脚本，不能写成test.sh，会被shell当成命令来查找 5.2 脚本作为解释器参数 这种方式是直接运行解释器，文件名作为参数，如/bin/sh test.sh 6. Shell作为用户与内核交互操作的接口 6.1 为什么要有Shell？ Shell的存在是有很多好处的。假设在同福客栈里没有了接待员老白，让你自己去操作点菜机，你不知道如何操作点菜机怎么办？你点了一道不存在的菜怎么办？ 6.2 为什么有多种Shell？ 假设同福客栈偶尔还接待外宾，点菜的时候说的是外语。而接待员老白不会说外语，那么我们是不是就需要另一个服务员（另一种Shell）了。不同的Shell是为了应对应用程序有不同的需求。 6.3 为什么要有系统调用？ 6.4 为什么要有内核？","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://holdfire.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://holdfire.github.io/tags/Linux/"}]},{"title":"Python虚拟环境","slug":"python-virtual-environment","date":"2019-10-26T09:00:10.000Z","updated":"2019-10-27T07:54:44.835Z","comments":true,"path":"2019/10/26/python-virtual-environment/","link":"","permalink":"http://holdfire.github.io/2019/10/26/python-virtual-environment/","excerpt":"","text":"1. Python虚拟环境简介 Python中所有的第三方包都会被pip安装到site-packages目录下。对于某个特定的Python包，在项目A中可能需要使用1.0版的，而项目B中需要使用1.1版的。如何解决这种冲突呢？ 解决方案是：创建两个不同的虚拟环境，这两个虚拟环境相互独立、互不干扰。不同的项目就可以分别在各自的虚拟环境中独立运行啦，完美！（引申：不同虚拟环境的包是独立的，那它们使用的Python解释器是共享的还是独立的呢？） 那么如何创建虚拟环境呢？接下来就总结一下几种常用的虚拟环境管理工具。 2. 几种虚拟环境管理工具 2.1 virtualenv工具 virtualenv工具在安装Anaconda时有自带，位于安装目录/Lib/site-packages目录下。如果没有安装，可以在终端命令行中输入pip install virtualenv命令安装。 创建虚拟环境： 12345mkdir my_project # 创建项目文件夹cd my_project # 进入项目路径下virtualenv env_name # 使用默认的python解释器创建虚拟环境virtualenv -p path env_name # 使用path路径下的python解释器创建虚拟环境，Linux下path通常为/usr/bin/python,Windows中如e:/anaconda/python.exe # 使用virtualenv -h 可查看创建虚拟环境时的其他参数 操作虚拟环境： 1234567# Linux下操作虚拟环境source env_name/bin/activate # 激活该虚拟环境，之后所有的操作都在该环境中deactivate # 退出该虚拟环境rm -rf env_name # 删除该虚拟环境# Windows下操作虚拟环境，退出和删除操作同上cd env_name/Scripts/ # 进入到activate文件所在的目录activate # 执行activate文件，激活该虚拟环境 2.2 virtualenvwrapper工具 用户可以使用virtualenv工具在系统的任意地方创建虚拟环境。但下次需要激活这个环境时仍需要使用source env_path/activate命令，然而同学你可能早已忘记虚拟环境的路径env_path。 为了让用户更方便使用，我们可以把虚拟环境集中进行管理，virtualenvwrapper工具应运而生。在使用之前，你得先安装了virtualenv，然后再安装virtualenvwrapper。安装命令： pip install virtualenvwrapper # Linux下安装命令 pip install virtualenvwrapper-win # Windows下安装命令","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://holdfire.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://holdfire.github.io/tags/Python/"}]},{"title":"支持向量机SVM","slug":"SVM","date":"2019-10-25T15:43:05.000Z","updated":"2019-10-25T20:32:46.082Z","comments":true,"path":"2019/10/25/SVM/","link":"","permalink":"http://holdfire.github.io/2019/10/25/SVM/","excerpt":"","text":"1. 支持向量机简介 支持向量机(Support Vector Machine, SVM)是一种二分类模型。其分类决策函数为： f(x)=sign(wT⋅x+b)(1)\\tag{1} f(x)=sign(w^T \\cdot x+b) f(x)=sign(wT⋅x+b)(1) 线性可分支持向量机学习的最优化问题为： min⁡w,b 12∥w∥2(2)\\tag{2}\\min_{w,b}\\ \\ \\ \\frac {1} {2} \\begin{Vmatrix} w \\end{Vmatrix}^2 w,bmin​ 21​∥∥​w​∥∥​2(2) s. t. yi(w⋅xi+b)−1 ≥0 i=1,2,...,N(3)\\tag{3} s.\\ t.\\ \\ \\ y_i(\\bm w\\cdot \\bm x_i+b)-1\\ \\ge 0\\ \\ \\ \\ \\ i=1,2,...,N s. t. yi​(w⋅xi​+b)−1 ≥0 i=1,2,...,N(3) 对每一个不等式约束引入拉格朗日乘子αi≥0, i=1,2,...,N\\alpha _i \\ge 0,\\ \\ i=1,2,...,Nαi​≥0, i=1,2,...,N后构造拉格朗日泛函L(w,b,α)L(\\bm w,b,\\bm \\alpha )L(w,b,α)，则上述优化问题等价为： min⁡w,b max⁡α L(w,b,α)=12∥w∥2−∑i=1Nαi[yi(w⋅xi+b)−1](4)\\tag{4} \\min_{\\bm w,b}\\ \\max_{\\bm \\alpha}\\ L(\\bm w,b,\\bm \\alpha )=\\frac 1 2\\begin{Vmatrix} w \\end{Vmatrix}^2-\\sum_{i=1} ^N \\alpha _i [y_i(\\bm w\\cdot \\bm x_i+b)-1] w,bmin​ αmax​ L(w,b,α)=21​∥∥​w​∥∥​2−i=1∑N​αi​[yi​(w⋅xi​+b)−1](4) 在上式的鞍点处，目标函数L(w,b,α)L(\\bm w,b,\\bm \\alpha )L(w,b,α)对w\\bm ww和bbb的偏导数为零。由此得到，在最优解处满足： w∗=∑i=1Nαiyixi(5)\\tag{5} \\bm w^*= \\sum_{i=1} ^N \\alpha _i y_i \\bm x _i w∗=i=1∑N​αi​yi​xi​(5) ∑i=1nαi∗yi=0(6)\\tag{6} \\sum_{i=1} ^n {\\alpha _i}^* y_i = 0 i=1∑n​αi​∗yi​=0(6) 将上面两个条件代入拉格朗日泛函中，则原问题的解等价于下面对偶问题的解： max⁡α Q(α)=∑i=1Nαi−12∑i=1N∑j=1Nαiαjyiyj(xi⋅xj)(7)\\tag{7}\\max_{\\bm \\alpha}\\ \\ Q(\\bm \\alpha)=\\sum_{i=1} ^N \\alpha _i -\\frac 1 2 \\sum_{i=1} ^N \\sum_{j=1} ^N \\alpha _i \\alpha _j y_i y_j(\\bm x_i \\cdot \\bm x_j) αmax​ Q(α)=i=1∑N​αi​−21​i=1∑N​j=1∑N​αi​αj​yi​yj​(xi​⋅xj​)(7) s. t. ∑i=1Nαiyi=0(8)\\tag{8} s.\\ t.\\ \\ \\ \\ \\sum_{i=1} ^N \\alpha _i y_i=0 s. t. i=1∑N​αi​yi​=0(8) αi≥0 i=1,2,...,N(9)\\tag{9} \\alpha _i \\ge 0\\ \\ i=1,2,...,N αi​≥0 i=1,2,...,N(9) 通过对偶问题的解αi∗, i=1,2,...,N\\alpha _i^*,\\ i=1,2,...,Nαi∗​, i=1,2,...,N，代入上式（5）中可以求出原问题的解w∗\\bm w^*w∗，接下看如何求解b。 根据最优化理论中的KKT条件，如果原问题的最优解为对偶问题的最优解，需要满足： αi[yi(w⋅xi+b)−1]=0(10)\\tag{10}\\alpha _i [y_i(\\bm w\\cdot \\bm x_i+b)-1]=0 αi​[yi​(w⋅xi​+b)−1]=0(10) 支持向量对应的αi\\alpha _iαi​是大于0的，因而对于这些点有： yi(w⋅xi+b)−1=0(11)\\tag{11} y_i(\\bm w\\cdot \\bm x_i+b)-1=0 yi​(w⋅xi​+b)−1=0(11) 因为已经求出了w∗\\bm w^*w∗,所以b∗b^*b∗可以用任何支持向量根据上式求得。实际数值计算中，人们通常采用所有非求解αi\\alpha _iαi​非零的样本求解b∗b^*b∗再取平均值。 2. 线性支持向量机与软间隔最大化 3. 非线性支持向量机与核函数","categories":[{"name":"算法","slug":"算法","permalink":"http://holdfire.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://holdfire.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"网站出生的第一天","slug":"my_first_blog","date":"2019-10-25T10:51:19.000Z","updated":"2019-10-25T19:00:16.314Z","comments":true,"path":"2019/10/25/my_first_blog/","link":"","permalink":"http://holdfire.github.io/2019/10/25/my_first_blog/","excerpt":"","text":"1. 网站简介 这是holdfire于2019年10月25日创建的个人博客网站。创建步骤： 首先，在个人电脑上安装node.js(一种运行在服务端的 JavaScript，包含环境变量及npm的安装)； 然后，安装个人博客网站框架Hexo(在cmd中使用npm install -g hexo-cli等)； 接下来，创建一个新文件夹，执行hexo init,初始化自己的博客网站。用hexo s命令可以运行该网站。就可以在浏览器中访问啦！ 最后，在站点配置文档_config.yml中，设置你的github仓库地址，将网站内容托管在github上，就可以通过域名访问啦！ 补充，可以在hexo官网中下载各种自己喜欢的网站主题，然后修改主题配置文档_config.yml即可。","categories":[{"name":"软件安装","slug":"软件安装","permalink":"http://holdfire.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://holdfire.github.io/tags/web%E5%89%8D%E7%AB%AF/"}]}]}