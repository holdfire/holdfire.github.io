{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://holdfire.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-10-25T15:05:32.600Z","updated":"2019-10-25T11:35:08.028Z","comments":false,"path":"about/index.html","permalink":"http://holdfire.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2019-10-26T09:18:00.989Z","updated":"2019-10-25T11:35:08.047Z","comments":true,"path":"links/index.html","permalink":"http://holdfire.github.io/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2019-10-25T19:41:07.133Z","updated":"2019-10-25T11:35:08.034Z","comments":false,"path":"books/index.html","permalink":"http://holdfire.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-25T15:06:18.978Z","updated":"2019-10-25T11:35:08.041Z","comments":false,"path":"categories/index.html","permalink":"http://holdfire.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-10-25T11:35:08.054Z","updated":"2019-10-25T11:35:08.054Z","comments":false,"path":"repository/index.html","permalink":"http://holdfire.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-25T11:35:08.060Z","updated":"2019-10-25T11:35:08.060Z","comments":false,"path":"tags/index.html","permalink":"http://holdfire.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux学习————Shell篇（1）","slug":"linux-shell-1","date":"2019-10-26T16:00:27.000Z","updated":"2019-10-26T17:34:30.363Z","comments":true,"path":"2019/10/27/linux-shell-1/","link":"","permalink":"http://holdfire.github.io/2019/10/27/linux-shell-1/","excerpt":"","text":"1. Shell是什么？ 想象一下场景A：你去同福客栈吃饭，你对店小二老白说：“我要一份水煮酸菜鱼。”老白对着你点头微笑表示ok。于是，在点菜机器上输入一堆信息后，该消息传到了后厨李大嘴那里，李大嘴开始鼓捣起他的菜刀、砧板、铁锅等工具。一个小时过后，一份既不好看也不好吃的酸菜鱼终于摆到了你的面前。 想象一下场景B：你在Linux终端工具上写代码，你写下了一行echo &quot;Hello, World&quot;,Shell对这行代码进行解释。然后，系统调用收到了该解释信息后，这个解释传到了操作系统内核那里，内核开始控制CPU、内存、显卡等玩意。不到1s的时间，你的显示器上就显示出了&quot;Hello, World&quot;这行字。 **所以，Shell是什么？Shell是一个用C语言编写的程序！Shell是一个命令解释器！Shell是一种命令语言！Shell是一种程序设计语言！Shell是系统的用户界面，提供了用户与内核进行交互操作的接口！上面是网上找到的关于Shell的几乎所有解释，听着让人头大。再看看我我们场景A，我的解释是：如果你认同场景A等价于场景B，那么Shell就是老白！**后面关于Shell的所有解释，我都引用到场景A的例子。 首先，电脑的硬件由CPU、内存、显卡、磁盘等组成；这些硬件由操作系统（包括内核和系统调用两部分）的内核（kernel）来控制，内核包括CPU调度、内存管理、磁盘输入输出等工作；那么我们用户是如何与内核进行沟通的呢？答案就是通过Shell（外壳）。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://holdfire.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://holdfire.github.io/tags/Linux/"}]},{"title":"Python虚拟环境","slug":"python-virtual-environment","date":"2019-10-26T09:00:10.000Z","updated":"2019-10-26T13:26:56.131Z","comments":true,"path":"2019/10/26/python-virtual-environment/","link":"","permalink":"http://holdfire.github.io/2019/10/26/python-virtual-environment/","excerpt":"","text":"1. Python虚拟环境简介 Python中所有的第三方包都会被pip安装到site-packages目录下。对于某个特定的Python包，在项目A中可能需要使用1.0版的，而项目B中需要使用1.1版的。如何解决这种冲突呢？ 解决方案是：创建两个不同的虚拟环境，这两个虚拟环境相互独立、互不干扰。不同的项目就可以分别在各自的虚拟环境中独立运行啦，完美！（引申：不同虚拟环境的包是独立的，那它们使用的Python解释器是共享的还是独立的呢？） 那么如何创建虚拟环境呢？接下来就总结一下几种常用的虚拟环境管理工具。 2. 几种虚拟环境管理工具 2.1 virtualenv工具 virtualenv工具在安装Anaconda时有自带，位于安装目录/Lib/site-packages目录下。如果没有安装，可以在终端命令行中输入pip install virtualenv命令安装。 创建虚拟环境： 12345mkdir my_project # 创建项目文件夹cd my_project # 进入项目路径下virtualenv env_name # 使用默认的python解释器创建虚拟环境virtualenv -p path env_name # 使用path路径下的python解释器创建虚拟环境，Linux下path通常为/usr/bin/python,Windows中如e:/anaconda/python.exe # 使用virtualenv -h 可查看创建虚拟环境时的其他参数 操作虚拟环境： 1234567# Linux下操作虚拟环境source env_name/bin/activate # 激活该虚拟环境，之后所有的操作都在该环境中deactivate # 退出该虚拟环境rm -rf env_name # 删除该虚拟环境# Windows下操作虚拟环境，退出和删除操作同上cd env_name/Scripts/ # 进入到activate文件所在的目录activate # 执行activate文件，激活该虚拟环境 2.2 virtualenvwrapper工具 用户可以使用virtualenv工具在系统的任意地方创建虚拟环境。但下次需要激活这个环境时仍需要使用source env_path/activate命令，然而同学你可能早已忘记虚拟环境的路径env_path。 为了让用户更方便使用，我们可以把虚拟环境集中进行管理，virtualenvwrapper工具应运而生。在使用之前，你得先安装了virtualenv，然后再安装virtualenvwrapper。安装命令： pip install virtualenvwrapper # Linux下安装命令 pip install virtualenvwrapper-win # Windows下安装命令","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://holdfire.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://holdfire.github.io/tags/Python/"}]},{"title":"支持向量机SVM","slug":"SVM","date":"2019-10-25T15:43:05.000Z","updated":"2019-10-25T20:32:46.082Z","comments":true,"path":"2019/10/25/SVM/","link":"","permalink":"http://holdfire.github.io/2019/10/25/SVM/","excerpt":"","text":"1. 支持向量机简介 支持向量机(Support Vector Machine, SVM)是一种二分类模型。其分类决策函数为： f(x)=sign(wT⋅x+b)(1)\\tag{1} f(x)=sign(w^T \\cdot x+b) f(x)=sign(wT⋅x+b)(1) 线性可分支持向量机学习的最优化问题为： min⁡w,b 12∥w∥2(2)\\tag{2}\\min_{w,b}\\ \\ \\ \\frac {1} {2} \\begin{Vmatrix} w \\end{Vmatrix}^2 w,bmin​ 21​∥∥​w​∥∥​2(2) s. t. yi(w⋅xi+b)−1 ≥0 i=1,2,...,N(3)\\tag{3} s.\\ t.\\ \\ \\ y_i(\\bm w\\cdot \\bm x_i+b)-1\\ \\ge 0\\ \\ \\ \\ \\ i=1,2,...,N s. t. yi​(w⋅xi​+b)−1 ≥0 i=1,2,...,N(3) 对每一个不等式约束引入拉格朗日乘子αi≥0, i=1,2,...,N\\alpha _i \\ge 0,\\ \\ i=1,2,...,Nαi​≥0, i=1,2,...,N后构造拉格朗日泛函L(w,b,α)L(\\bm w,b,\\bm \\alpha )L(w,b,α)，则上述优化问题等价为： min⁡w,b max⁡α L(w,b,α)=12∥w∥2−∑i=1Nαi[yi(w⋅xi+b)−1](4)\\tag{4} \\min_{\\bm w,b}\\ \\max_{\\bm \\alpha}\\ L(\\bm w,b,\\bm \\alpha )=\\frac 1 2\\begin{Vmatrix} w \\end{Vmatrix}^2-\\sum_{i=1} ^N \\alpha _i [y_i(\\bm w\\cdot \\bm x_i+b)-1] w,bmin​ αmax​ L(w,b,α)=21​∥∥​w​∥∥​2−i=1∑N​αi​[yi​(w⋅xi​+b)−1](4) 在上式的鞍点处，目标函数L(w,b,α)L(\\bm w,b,\\bm \\alpha )L(w,b,α)对w\\bm ww和bbb的偏导数为零。由此得到，在最优解处满足： w∗=∑i=1Nαiyixi(5)\\tag{5} \\bm w^*= \\sum_{i=1} ^N \\alpha _i y_i \\bm x _i w∗=i=1∑N​αi​yi​xi​(5) ∑i=1nαi∗yi=0(6)\\tag{6} \\sum_{i=1} ^n {\\alpha _i}^* y_i = 0 i=1∑n​αi​∗yi​=0(6) 将上面两个条件代入拉格朗日泛函中，则原问题的解等价于下面对偶问题的解： max⁡α Q(α)=∑i=1Nαi−12∑i=1N∑j=1Nαiαjyiyj(xi⋅xj)(7)\\tag{7}\\max_{\\bm \\alpha}\\ \\ Q(\\bm \\alpha)=\\sum_{i=1} ^N \\alpha _i -\\frac 1 2 \\sum_{i=1} ^N \\sum_{j=1} ^N \\alpha _i \\alpha _j y_i y_j(\\bm x_i \\cdot \\bm x_j) αmax​ Q(α)=i=1∑N​αi​−21​i=1∑N​j=1∑N​αi​αj​yi​yj​(xi​⋅xj​)(7) s. t. ∑i=1Nαiyi=0(8)\\tag{8} s.\\ t.\\ \\ \\ \\ \\sum_{i=1} ^N \\alpha _i y_i=0 s. t. i=1∑N​αi​yi​=0(8) αi≥0 i=1,2,...,N(9)\\tag{9} \\alpha _i \\ge 0\\ \\ i=1,2,...,N αi​≥0 i=1,2,...,N(9) 通过对偶问题的解αi∗, i=1,2,...,N\\alpha _i^*,\\ i=1,2,...,Nαi∗​, i=1,2,...,N，代入上式（5）中可以求出原问题的解w∗\\bm w^*w∗，接下看如何求解b。 根据最优化理论中的KKT条件，如果原问题的最优解为对偶问题的最优解，需要满足： αi[yi(w⋅xi+b)−1]=0(10)\\tag{10}\\alpha _i [y_i(\\bm w\\cdot \\bm x_i+b)-1]=0 αi​[yi​(w⋅xi​+b)−1]=0(10) 支持向量对应的αi\\alpha _iαi​是大于0的，因而对于这些点有： yi(w⋅xi+b)−1=0(11)\\tag{11} y_i(\\bm w\\cdot \\bm x_i+b)-1=0 yi​(w⋅xi​+b)−1=0(11) 因为已经求出了w∗\\bm w^*w∗,所以b∗b^*b∗可以用任何支持向量根据上式求得。实际数值计算中，人们通常采用所有非求解αi\\alpha _iαi​非零的样本求解b∗b^*b∗再取平均值。 2. 线性支持向量机与软间隔最大化 3. 非线性支持向量机与核函数","categories":[{"name":"算法","slug":"算法","permalink":"http://holdfire.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://holdfire.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"网站出生的第一天","slug":"my_first_blog","date":"2019-10-25T10:51:19.000Z","updated":"2019-10-25T19:00:16.314Z","comments":true,"path":"2019/10/25/my_first_blog/","link":"","permalink":"http://holdfire.github.io/2019/10/25/my_first_blog/","excerpt":"","text":"1. 网站简介 这是holdfire于2019年10月25日创建的个人博客网站。创建步骤： 首先，在个人电脑上安装node.js(一种运行在服务端的 JavaScript，包含环境变量及npm的安装)； 然后，安装个人博客网站框架Hexo(在cmd中使用npm install -g hexo-cli等)； 接下来，创建一个新文件夹，执行hexo init,初始化自己的博客网站。用hexo s命令可以运行该网站。就可以在浏览器中访问啦！ 最后，在站点配置文档_config.yml中，设置你的github仓库地址，将网站内容托管在github上，就可以通过域名访问啦！ 补充，可以在hexo官网中下载各种自己喜欢的网站主题，然后修改主题配置文档_config.yml即可。","categories":[{"name":"软件安装","slug":"软件安装","permalink":"http://holdfire.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://holdfire.github.io/tags/web%E5%89%8D%E7%AB%AF/"}]}]}