{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://holdfire.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-10-25T15:05:32.600Z","updated":"2019-10-25T11:35:08.028Z","comments":false,"path":"about/index.html","permalink":"http://holdfire.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2019-10-25T19:41:07.133Z","updated":"2019-10-25T11:35:08.034Z","comments":false,"path":"books/index.html","permalink":"http://holdfire.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-25T15:06:18.978Z","updated":"2019-10-25T11:35:08.041Z","comments":false,"path":"categories/index.html","permalink":"http://holdfire.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-10-26T09:18:00.989Z","updated":"2019-10-25T11:35:08.047Z","comments":true,"path":"links/index.html","permalink":"http://holdfire.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-10-25T11:35:08.054Z","updated":"2019-10-25T11:35:08.054Z","comments":false,"path":"repository/index.html","permalink":"http://holdfire.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-25T11:35:08.060Z","updated":"2019-10-25T11:35:08.060Z","comments":false,"path":"tags/index.html","permalink":"http://holdfire.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux学习——文件系统与目录篇(1)","slug":"linux-file-directory-1","date":"2019-10-26T19:17:45.000Z","updated":"2019-10-26T19:21:15.427Z","comments":true,"path":"2019/10/27/linux-file-directory-1/","link":"","permalink":"http://holdfire.github.io/2019/10/27/linux-file-directory-1/","excerpt":"","text":"1. Linux的文件权限","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://holdfire.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://holdfire.github.io/tags/Linux/"}]},{"title":"Linux学习——简介","slug":"linux-introduction","date":"2019-10-26T18:30:34.000Z","updated":"2019-10-26T19:29:14.335Z","comments":true,"path":"2019/10/27/linux-introduction/","link":"","permalink":"http://holdfire.github.io/2019/10/27/linux-introduction/","excerpt":"","text":"1. Linux简介 Linux是一个GNU GPL授权模式的开源的操作系统。操作系统由内核和系统调用组成,操作系统是应用程序和计算机硬件沟通的桥梁。即：硬件–&gt;内核–&gt;系统调用–&gt;应用程序(Shell)。 1.1 Linux内核版本与发行版本 Linux内核版本是单线发展的，其版本号由“主版本.次版本.末版本”的格式构成。截至2019年10月27日，最新的Linux稳定内核版本为5.3.7版。 Linux发行版本是由“Linux内核+软件+工具+文件”组成的一个完整的安装程序，不同的厂商提供不同的发行版本，主要分为两大类： 使用rpm/yum包管理方式的系统，包括：RedHat,Fedora,CentOS等； 使用apt-get/dpkg包管理方式的系统，包括：Debian,Ubuntu等； 1.2 Linux的特点 Linux严格区分大小写； Linux中一切内容皆文件（包括硬件）； Linux不依靠拓展名区分文件类型，而是依据文件权限； 通常，压缩包的后缀为.gz .bz2 .tar .bz2 .tgz；二进制软件包为.rmp；脚本文件为 .sh 2. Linux文件系统和目录 3. Shell与Shell脚本 4. Linux用户管理 5. Linux系统管理","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://holdfire.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://holdfire.github.io/tags/Linux/"}]},{"title":"Linux学习——Shell篇(1)","slug":"linux-shell-1","date":"2019-10-26T16:00:27.000Z","updated":"2019-10-26T20:42:02.752Z","comments":true,"path":"2019/10/27/linux-shell-1/","link":"","permalink":"http://holdfire.github.io/2019/10/27/linux-shell-1/","excerpt":"","text":"1. Shell是什么？ 1.1 正规军的解释 Shell是一个用C语言编写的程序！Shell是一个命令解释器！Shell是一种命令语言！Shell是一种程序设计语言！Shell是系统的用户界面，提供了用户与内核进行交互操作的接口！上面是网上找到的关于Shell的大部分解释，听着是不是让人头大？是的？！那就忘掉它，看看下面两个场景先。 1.2 酸菜鱼和Hello,world 场景A：你去同福客栈吃饭，你对店小二老白说：“我要一份酸菜鱼。”老白对着你点头微笑表示ok，然后跑去前台的点菜机上噼里啪啦输入一堆信息，该消息就被传到了后厨李大嘴那里，李大嘴开始鼓捣起他的菜刀、砧板、狼牙棒等厨房工具。一个时辰过后，你的桌上终于出现了一份既不好看也不好吃的酸菜鱼。 场景B：你在Linux终端工具上写代码，你写下了一行echo &quot;Hello, world&quot;,Shell对这行代码进行了解释，然后系统调用收到了该解释信息，信息接下来被传到了内核那里，内核开始控制CPU、内存、显卡等设备。一眨眼的时间，你的显示器上就出现了&quot;Hello, world&quot;这行字。 补充概念：计算机的硬件由CPU、内存、显卡、磁盘等组成。操作系统包括内核和系统调用，内核（kernel，包括CPU调度、内存管理、磁盘输入输出等）直接控制上述硬件，系统调用是应用程序同系统之间的接口(API)，eg:Linux操作系统中如内存管理、网络、Socket套接字、进程间通信等接口。 1.3 游击队的解释 场景A中信息的流动方向是：你的话–&gt;老白–&gt;点菜机—&gt;李大嘴–&gt;厨具，场景B中信息的流动方向是：你的代码–&gt;Shell–&gt;系统调用—&gt;内核–&gt;硬件。仅考虑信息的流动方向，如果我们认可场景A等价于场景B，那么，Shell是什么？Shell就是老白！ 回过头来看1.1中的解释，把Shell替换成老白，Shell到底是什么，是不是就很好理解了呢？ 2. Shell简介 2.1 Shell的家族 常见的shell有Bourne shell(简称sh),在Sun里默认的C shell(简称csh)等。Linux使用的版本是Bourne Again Shell(简称bash)，它是Bourne shell的增强版本。 2.2 Linux中的Shell 在linux中，查看/etc/shells这个文件，就可以看到当前可以使用的shell种类了。我在ubuntu 16.04.5上查看的结果是下面4种： 1234/bin/sh # 已经被/bin/bash所替换/bin/dash/bin/bash # Linux默认的shell/bin/rbash","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://holdfire.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://holdfire.github.io/tags/Linux/"}]},{"title":"Python虚拟环境","slug":"python-virtual-environment","date":"2019-10-26T09:00:10.000Z","updated":"2019-10-26T13:26:56.131Z","comments":true,"path":"2019/10/26/python-virtual-environment/","link":"","permalink":"http://holdfire.github.io/2019/10/26/python-virtual-environment/","excerpt":"","text":"1. Python虚拟环境简介 Python中所有的第三方包都会被pip安装到site-packages目录下。对于某个特定的Python包，在项目A中可能需要使用1.0版的，而项目B中需要使用1.1版的。如何解决这种冲突呢？ 解决方案是：创建两个不同的虚拟环境，这两个虚拟环境相互独立、互不干扰。不同的项目就可以分别在各自的虚拟环境中独立运行啦，完美！（引申：不同虚拟环境的包是独立的，那它们使用的Python解释器是共享的还是独立的呢？） 那么如何创建虚拟环境呢？接下来就总结一下几种常用的虚拟环境管理工具。 2. 几种虚拟环境管理工具 2.1 virtualenv工具 virtualenv工具在安装Anaconda时有自带，位于安装目录/Lib/site-packages目录下。如果没有安装，可以在终端命令行中输入pip install virtualenv命令安装。 创建虚拟环境： 12345mkdir my_project # 创建项目文件夹cd my_project # 进入项目路径下virtualenv env_name # 使用默认的python解释器创建虚拟环境virtualenv -p path env_name # 使用path路径下的python解释器创建虚拟环境，Linux下path通常为/usr/bin/python,Windows中如e:/anaconda/python.exe # 使用virtualenv -h 可查看创建虚拟环境时的其他参数 操作虚拟环境： 1234567# Linux下操作虚拟环境source env_name/bin/activate # 激活该虚拟环境，之后所有的操作都在该环境中deactivate # 退出该虚拟环境rm -rf env_name # 删除该虚拟环境# Windows下操作虚拟环境，退出和删除操作同上cd env_name/Scripts/ # 进入到activate文件所在的目录activate # 执行activate文件，激活该虚拟环境 2.2 virtualenvwrapper工具 用户可以使用virtualenv工具在系统的任意地方创建虚拟环境。但下次需要激活这个环境时仍需要使用source env_path/activate命令，然而同学你可能早已忘记虚拟环境的路径env_path。 为了让用户更方便使用，我们可以把虚拟环境集中进行管理，virtualenvwrapper工具应运而生。在使用之前，你得先安装了virtualenv，然后再安装virtualenvwrapper。安装命令： pip install virtualenvwrapper # Linux下安装命令 pip install virtualenvwrapper-win # Windows下安装命令","categories":[{"name":"编程语言","slug":"编程语言","permalink":"http://holdfire.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://holdfire.github.io/tags/Python/"}]},{"title":"支持向量机SVM","slug":"SVM","date":"2019-10-25T15:43:05.000Z","updated":"2019-10-25T20:32:46.082Z","comments":true,"path":"2019/10/25/SVM/","link":"","permalink":"http://holdfire.github.io/2019/10/25/SVM/","excerpt":"","text":"1. 支持向量机简介 支持向量机(Support Vector Machine, SVM)是一种二分类模型。其分类决策函数为： f(x)=sign(wT⋅x+b)(1)\\tag{1} f(x)=sign(w^T \\cdot x+b) f(x)=sign(wT⋅x+b)(1) 线性可分支持向量机学习的最优化问题为： min⁡w,b 12∥w∥2(2)\\tag{2}\\min_{w,b}\\ \\ \\ \\frac {1} {2} \\begin{Vmatrix} w \\end{Vmatrix}^2 w,bmin​ 21​∥∥​w​∥∥​2(2) s. t. yi(w⋅xi+b)−1 ≥0 i=1,2,...,N(3)\\tag{3} s.\\ t.\\ \\ \\ y_i(\\bm w\\cdot \\bm x_i+b)-1\\ \\ge 0\\ \\ \\ \\ \\ i=1,2,...,N s. t. yi​(w⋅xi​+b)−1 ≥0 i=1,2,...,N(3) 对每一个不等式约束引入拉格朗日乘子αi≥0, i=1,2,...,N\\alpha _i \\ge 0,\\ \\ i=1,2,...,Nαi​≥0, i=1,2,...,N后构造拉格朗日泛函L(w,b,α)L(\\bm w,b,\\bm \\alpha )L(w,b,α)，则上述优化问题等价为： min⁡w,b max⁡α L(w,b,α)=12∥w∥2−∑i=1Nαi[yi(w⋅xi+b)−1](4)\\tag{4} \\min_{\\bm w,b}\\ \\max_{\\bm \\alpha}\\ L(\\bm w,b,\\bm \\alpha )=\\frac 1 2\\begin{Vmatrix} w \\end{Vmatrix}^2-\\sum_{i=1} ^N \\alpha _i [y_i(\\bm w\\cdot \\bm x_i+b)-1] w,bmin​ αmax​ L(w,b,α)=21​∥∥​w​∥∥​2−i=1∑N​αi​[yi​(w⋅xi​+b)−1](4) 在上式的鞍点处，目标函数L(w,b,α)L(\\bm w,b,\\bm \\alpha )L(w,b,α)对w\\bm ww和bbb的偏导数为零。由此得到，在最优解处满足： w∗=∑i=1Nαiyixi(5)\\tag{5} \\bm w^*= \\sum_{i=1} ^N \\alpha _i y_i \\bm x _i w∗=i=1∑N​αi​yi​xi​(5) ∑i=1nαi∗yi=0(6)\\tag{6} \\sum_{i=1} ^n {\\alpha _i}^* y_i = 0 i=1∑n​αi​∗yi​=0(6) 将上面两个条件代入拉格朗日泛函中，则原问题的解等价于下面对偶问题的解： max⁡α Q(α)=∑i=1Nαi−12∑i=1N∑j=1Nαiαjyiyj(xi⋅xj)(7)\\tag{7}\\max_{\\bm \\alpha}\\ \\ Q(\\bm \\alpha)=\\sum_{i=1} ^N \\alpha _i -\\frac 1 2 \\sum_{i=1} ^N \\sum_{j=1} ^N \\alpha _i \\alpha _j y_i y_j(\\bm x_i \\cdot \\bm x_j) αmax​ Q(α)=i=1∑N​αi​−21​i=1∑N​j=1∑N​αi​αj​yi​yj​(xi​⋅xj​)(7) s. t. ∑i=1Nαiyi=0(8)\\tag{8} s.\\ t.\\ \\ \\ \\ \\sum_{i=1} ^N \\alpha _i y_i=0 s. t. i=1∑N​αi​yi​=0(8) αi≥0 i=1,2,...,N(9)\\tag{9} \\alpha _i \\ge 0\\ \\ i=1,2,...,N αi​≥0 i=1,2,...,N(9) 通过对偶问题的解αi∗, i=1,2,...,N\\alpha _i^*,\\ i=1,2,...,Nαi∗​, i=1,2,...,N，代入上式（5）中可以求出原问题的解w∗\\bm w^*w∗，接下看如何求解b。 根据最优化理论中的KKT条件，如果原问题的最优解为对偶问题的最优解，需要满足： αi[yi(w⋅xi+b)−1]=0(10)\\tag{10}\\alpha _i [y_i(\\bm w\\cdot \\bm x_i+b)-1]=0 αi​[yi​(w⋅xi​+b)−1]=0(10) 支持向量对应的αi\\alpha _iαi​是大于0的，因而对于这些点有： yi(w⋅xi+b)−1=0(11)\\tag{11} y_i(\\bm w\\cdot \\bm x_i+b)-1=0 yi​(w⋅xi​+b)−1=0(11) 因为已经求出了w∗\\bm w^*w∗,所以b∗b^*b∗可以用任何支持向量根据上式求得。实际数值计算中，人们通常采用所有非求解αi\\alpha _iαi​非零的样本求解b∗b^*b∗再取平均值。 2. 线性支持向量机与软间隔最大化 3. 非线性支持向量机与核函数","categories":[{"name":"算法","slug":"算法","permalink":"http://holdfire.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://holdfire.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"网站出生的第一天","slug":"my_first_blog","date":"2019-10-25T10:51:19.000Z","updated":"2019-10-25T19:00:16.314Z","comments":true,"path":"2019/10/25/my_first_blog/","link":"","permalink":"http://holdfire.github.io/2019/10/25/my_first_blog/","excerpt":"","text":"1. 网站简介 这是holdfire于2019年10月25日创建的个人博客网站。创建步骤： 首先，在个人电脑上安装node.js(一种运行在服务端的 JavaScript，包含环境变量及npm的安装)； 然后，安装个人博客网站框架Hexo(在cmd中使用npm install -g hexo-cli等)； 接下来，创建一个新文件夹，执行hexo init,初始化自己的博客网站。用hexo s命令可以运行该网站。就可以在浏览器中访问啦！ 最后，在站点配置文档_config.yml中，设置你的github仓库地址，将网站内容托管在github上，就可以通过域名访问啦！ 补充，可以在hexo官网中下载各种自己喜欢的网站主题，然后修改主题配置文档_config.yml即可。","categories":[{"name":"软件安装","slug":"软件安装","permalink":"http://holdfire.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"web前端","slug":"web前端","permalink":"http://holdfire.github.io/tags/web%E5%89%8D%E7%AB%AF/"}]}]}